from django.db import models
import uuid
import secrets
from django.utils import timezone
from django.contrib.auth.models import User

# Create your models here.

class NetworkEvent(models.Model):
    """
    Model to store network events captured by the IDS
    """
    SEVERITY_CHOICES = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('critical', 'Critical'),
    ]
    
    EVENT_TYPES = [
        ('connection', 'Connection'),
        ('port_scan', 'Port Scan'),
        ('ddos', 'DDoS Attack'),
        ('brute_force', 'Brute Force Attempt'),
        ('suspicious_packet', 'Suspicious Packet'),
        ('other', 'Other'),
    ]
    
    timestamp = models.DateTimeField(auto_now_add=True)
    source_ip = models.GenericIPAddressField()
    destination_ip = models.GenericIPAddressField()
    source_port = models.IntegerField(null=True, blank=True)
    destination_port = models.IntegerField(null=True, blank=True)
    protocol = models.CharField(max_length=10)
    packet_info = models.JSONField(default=dict)
    event_type = models.CharField(max_length=20, choices=EVENT_TYPES)
    severity = models.CharField(max_length=10, choices=SEVERITY_CHOICES, default='low')
    description = models.TextField()
    is_threat = models.BooleanField(default=False)
    
    def __str__(self):
        return f"{self.timestamp} - {self.event_type} - {self.source_ip}:{self.source_port} -> {self.destination_ip}:{self.destination_port}"

class Alert(models.Model):
    """
    Model to store alerts generated by the IDS
    """
    event = models.ForeignKey(NetworkEvent, on_delete=models.CASCADE, related_name='alerts')
    timestamp = models.DateTimeField(auto_now_add=True)
    message = models.TextField()
    is_sent = models.BooleanField(default=False)
    sent_timestamp = models.DateTimeField(null=True, blank=True)
    score_data = models.JSONField(default=dict, blank=True)
    
    def __str__(self):
        return f"{self.timestamp} - {self.event.event_type} - {self.is_sent}"
        
class BlockedIP(models.Model):
    """
    Model to store IPs that should be blocked
    """
    ip_address = models.GenericIPAddressField(unique=True)
    reason = models.TextField()
    added = models.DateTimeField(auto_now_add=True)
    active = models.BooleanField(default=True)
    
    def __str__(self):
        return f"{self.ip_address} - {'Active' if self.active else 'Inactive'}"

class Agent(models.Model):
    """Model representing a monitoring agent deployed on an endpoint"""
    STATUS_CHOICES = [
        ('online', 'Online'),
        ('offline', 'Offline'),
        ('pending', 'Pending Registration'),
        ('disabled', 'Disabled'),
    ]
    
    PLATFORM_CHOICES = [
        ('linux', 'Linux'),
        ('windows', 'Windows'),
        ('docker', 'Docker'),
        ('other', 'Other'),
    ]
    
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True, null=True)
    token = models.CharField(max_length=64, unique=True, editable=False)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    platform = models.CharField(max_length=20, choices=PLATFORM_CHOICES, default='linux')
    endpoint_ip = models.GenericIPAddressField(blank=True, null=True)
    endpoint_hostname = models.CharField(max_length=255, blank=True, null=True)
    last_seen = models.DateTimeField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Configuration parameters
    collection_interval = models.IntegerField(default=60, help_text="Collection interval in seconds")
    enabled = models.BooleanField(default=True)
    config = models.JSONField(default=dict, blank=True)
    
    def __str__(self):
        return f"{self.name} ({self.get_status_display()})"
    
    def save(self, *args, **kwargs):
        # Generate token if not set
        if not self.token:
            self.token = secrets.token_hex(32)
        super().save(*args, **kwargs)
    
    def update_status(self, is_online=True):
        """Update agent status based on connectivity"""
        if is_online:
            self.status = 'online'
            self.last_seen = timezone.now()
        else:
            # Only mark as offline if it was previously online
            if self.status == 'online':
                self.status = 'offline'
        self.save(update_fields=['status', 'last_seen'])
    
    def disable(self):
        """Disable the agent"""
        self.status = 'disabled'
        self.enabled = False
        self.save(update_fields=['status', 'enabled'])
    
    @property
    def is_active(self):
        """Check if agent is active"""
        return self.status in ['online', 'offline'] and self.enabled

class AgentLog(models.Model):
    """Model for logs collected from agents"""
    agent = models.ForeignKey(Agent, on_delete=models.CASCADE, related_name='logs')
    timestamp = models.DateTimeField(default=timezone.now)
    log_type = models.CharField(max_length=50)
    source = models.CharField(max_length=100)   # e.g., 'syslog', 'auth.log', 'apache'
    content = models.TextField()
    parsed_data = models.JSONField(default=dict, blank=True)
    is_processed = models.BooleanField(default=False)
    
    def __str__(self):
        return f"{self.agent.name} - {self.log_type} - {self.timestamp}"

class DetectionRule(models.Model):
    """Model for intrusion detection rules"""
    RULE_TYPES = [
        ('signature', 'Signature-Based'),
        ('anomaly', 'Anomaly-Based'),
        ('threshold', 'Threshold-Based'),
    ]
    
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True, null=True)
    enabled = models.BooleanField(default=True)
    rule_type = models.CharField(max_length=20, choices=RULE_TYPES)
    
    # For signature-based rules
    pattern = models.TextField(blank=True, null=True, 
                            help_text="Regex pattern for signature-based detection")
    
    # For threshold-based rules
    metric = models.CharField(max_length=100, blank=True, null=True,
                           help_text="Metric to monitor (e.g., packets_per_second)")
    threshold = models.FloatField(blank=True, null=True,
                               help_text="Threshold value for triggering the rule")
    time_window = models.IntegerField(blank=True, null=True,
                                   help_text="Time window in seconds for the threshold")
    
    # For anomaly-based rules
    baseline_data = models.JSONField(blank=True, null=True,
                                  help_text="Baseline data for anomaly detection")
    deviation_factor = models.FloatField(blank=True, null=True, default=2.0,
                                      help_text="Factor by which a value can deviate from the baseline")
    
    # Common fields
    severity = models.CharField(max_length=20, choices=NetworkEvent.SEVERITY_CHOICES, default='medium')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Notification settings
    should_alert = models.BooleanField(default=True)
    alert_message_template = models.TextField(blank=True, null=True,
                                           help_text="Template for alert messages. Use {variables} for substitution.")
    
    def __str__(self):
        return f"{self.name} ({self.get_rule_type_display()})"
    
    def evaluate(self, data):
        """
        Evaluate data against this rule.
        
        Args:
            data (dict): Data to evaluate against the rule
            
        Returns:
            tuple: (is_match, details) where is_match is a boolean and details is a dict
        """
        if not self.enabled:
            return False, {"reason": "Rule disabled"}
        
        if self.rule_type == 'signature':
            return self._evaluate_signature(data)
        elif self.rule_type == 'threshold':
            return self._evaluate_threshold(data)
        elif self.rule_type == 'anomaly':
            return self._evaluate_anomaly(data)
        
        return False, {"reason": "Unknown rule type"}
    
    def _evaluate_signature(self, data):
        """Evaluate a signature-based rule"""
        import re
        
        if not self.pattern:
            return False, {"reason": "No pattern defined"}
        
        # Get the content to match against
        content = data.get('content', '')
        if not content:
            return False, {"reason": "No content to match"}
            
        try:
            match = re.search(self.pattern, content)
            if match:
                return True, {
                    "match": match.group(0),
                    "groups": match.groups()
                }
        except re.error:
            return False, {"reason": "Invalid regex pattern"}
            
        return False, {"reason": "No match found"}
    
    def _evaluate_threshold(self, data):
        """Evaluate a threshold-based rule"""
        if not self.metric or self.threshold is None:
            return False, {"reason": "Incomplete threshold rule configuration"}
        
        value = data.get(self.metric)
        if value is None:
            return False, {"reason": f"Metric {self.metric} not found in data"}
        
        try:
            value = float(value)
            if value >= self.threshold:
                return True, {
                    "value": value,
                    "threshold": self.threshold,
                    "metric": self.metric
                }
        except (ValueError, TypeError):
            return False, {"reason": f"Invalid value for metric {self.metric}"}
            
        return False, {"reason": "Value below threshold"}
    
    def _evaluate_anomaly(self, data):
        """Evaluate an anomaly-based rule"""
        if not self.baseline_data or self.deviation_factor is None:
            return False, {"reason": "Incomplete anomaly rule configuration"}
        
        metric = data.get('metric')
        value = data.get('value')
        
        if metric is None or value is None:
            return False, {"reason": "Missing metric or value in data"}
        
        try:
            baseline = self.baseline_data.get(metric)
            if baseline is None:
                return False, {"reason": f"No baseline for metric {metric}"}
                
            value = float(value)
            baseline = float(baseline)
            
            # Calculate allowed range
            lower_bound = baseline / self.deviation_factor
            upper_bound = baseline * self.deviation_factor
            
            if value < lower_bound or value > upper_bound:
                return True, {
                    "value": value,
                    "baseline": baseline,
                    "lower_bound": lower_bound,
                    "upper_bound": upper_bound,
                    "deviation": abs(value - baseline) / baseline
                }
        except (ValueError, TypeError):
            return False, {"reason": "Invalid value or baseline"}
            
        return False, {"reason": "Value within normal range"}

class RuleMatch(models.Model):
    """Model for storing rule match events"""
    rule = models.ForeignKey(DetectionRule, on_delete=models.CASCADE, related_name='matches')
    event = models.ForeignKey(NetworkEvent, on_delete=models.CASCADE, related_name='rule_matches')
    matched_at = models.DateTimeField(auto_now_add=True)
    match_data = models.JSONField(default=dict)
    
    def __str__(self):
        return f"{self.rule.name} match at {self.matched_at}"

class NotificationLog(models.Model):
    """Model for tracking notification history"""
    alert = models.ForeignKey('Alert', on_delete=models.CASCADE, related_name='notification_logs')
    timestamp = models.DateTimeField(auto_now_add=True)
    success = models.BooleanField(default=False)
    channels = models.CharField(max_length=100, help_text="Comma-separated list of notification channels used")
    error_message = models.TextField(blank=True, null=True)
    
    class Meta:
        ordering = ['-timestamp']
        verbose_name = 'Notification Log'
        verbose_name_plural = 'Notification Logs'
        
    def __str__(self):
        return f"Notification for Alert #{self.alert_id} at {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}"
        
    @property
    def channel_list(self):
        """Return the list of channels as a Python list"""
        if not self.channels:
            return []
        return self.channels.split(',')
